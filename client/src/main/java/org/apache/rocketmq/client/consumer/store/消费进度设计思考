消息消费进度的存储，广播模式与消费组无关，集群模式下以主题与消费组为键 保存该主题所有队列的消费进度。结合并发消息消费的整个流程，思考一下并发消息消费关于消息进度更新的问题。

1.消费者线程每处理完一个消息消费任务（ConsumeRequest）时会从ProcessQueue中移除本批消费的消息，并返回ProcessQueue中最小的偏移量，用该偏移量更新消息队列消费进度，
也就是说更新消费进度与消费任务中的消息没什么关系。
例如现在两个消费任务task1(queueOffset分别为20,40),task2(queueOffset分别为50,70),并且ProcessQueue中当前包含最小消息偏移量为10的消息，则task2消费结束后，将使用10去更新消费进度，并不会是70,。
当task1消费结束后，还是以10去更新消费队列消息进度，消息消费进度的推进取决于ProcessQueue中偏移量最小的消息消费速度。如果偏移量为10的消息消费成功后，加入ProcessQueue中包含消息偏移量为100的消息，
则直接用100更新消息消费进度。 那如果在消费消息偏移量为10的消息时发送了死锁导致一直无法被消费，那岂不是消息进度无法向前推进? 是，所以引入了一种消息拉取流控措施：DefaultMQPushConsumer#consumeConsurrentlyMaxSpan=2000,
消息处理队列ProcessQueue中最大消息偏移与最小消息偏移量不能超过该值，如果超过该值，则触发流控，将延迟该消息队列的消息拉取。

2.触发消息消费进度更新的另外一个是在进行消息负载时，如果消息消费队列被分配给其他消费者时，此时会将该ProcessQueue状态设置为droped,持久化该消息队列的消费进度，并从内存中移除。